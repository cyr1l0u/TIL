# Do it! Vue.js 입문

Do it! Vue.js 입문 예제로 이해하고 실전 프로젝트로 완성한다!

장기효 저 | 이지스퍼블리싱 | 2018년 02월 05일

![책 표지](images/do-it-vue-js.jpg)

Vue.js는 공식문석가 매우 잘 정리되어 있는 편인데, 빠르게 개념을 정리하고 싶어서, 우리나라 저자의 책을 구매하여 빠르게 읽었다.

## 목차

* 01 Vue.js 소개
* 02 개발 환경 설정 및 첫 번째 프로젝트
* 03 화면을 개발하기 위한 필수 단위 - 인스턴스 & 컴포넌트
* 04 상용 웹 앱을 개발하기 위한 필수 기술들 - 라우터 & HTTP 통신
* 05 화면을 개발하기 위한 기본 지식과 팁 - 템플릿 & 프로젝트 구성
* 06 실전 애플리케이션 만들기
* 07 Vue.js 고급 개발자 되기
* 현장 밀착 취재

저자가 소개하는 3일 코스

* 1일차: 1장-3장
* 2일차: 4장-6장 4절
* 3일차: 6장 5절-부록

## Vue.js 소개

Vue.js는 구글에서 앵귤러를 이용하던 개발자였던 에반 유(Evan You)에 의해 만들어졌다. 배우기 쉬운 프레임워크를 목표로 개발되었다.

뷰의 특징

* MVVM(Model-View-ViewModel) 구조로 이루어진다.
* 컴포넌트 기반 프레임워크
* 앵귤러의 데이터 바인딩 특성(Two-way data binding)과 리액트의 가상 돔(Virtual DOM) 기반 렌더링 특징(One-way data flow)을 모두 가지고 있다.

## 개발 환경 설정 및 첫 번째 프로젝트

* Atom: 개인적으로 현 시점에는 Visual Studio Code가 가장 나은 환경
* node.js
* 뷰 개발자 도구 (크롬 익스텐션): 로컬 접속 허용

## 인스턴스 & 컴포넌트

### 뷰 인스턴스

인스턴스로 지정한 유효 범위가 존재

인스턴스를 생성하면, `created`, `mounted`를 거쳐 인스턴스가 화면에 부착되고, 모델 값이 변경되었을 때는 `updated` 함수가 호출되며, 인스턴스를 소멸과정에서 `destroyed` 함수가 호출된다. 각 상태함수 이전에 `beforeMethod`가 호출된다.

### 뷰 컴포넌트

전역 컴포넌트와 지역 컴포넌트로 구분되며, 접근 범위에 따라 구분된다. 전역 컴포넌트는 `Vue.component('컴포넌트 이름', {});`와 같이 정의된다.

지역 컴포넌트는 뷰 인스턴스 안에서 `components` 속성으로 정의된다.

### 뷰 컴포넌트 통신

Vue.js는 앵귤러1이나 백본과 달리 한 화면에 여러개의 컴포넌트를 가지므로, 각 컴포넌트 안의 지역 컴포넌트는 서로 다른 컴포넌트의 자료에 접근할 수 없다.

부모-자식간 관계를 통해서 자료를 주고 받을 수 있다. 이 때 `props` 속성을 이용한다.

자식 컴포넌트에 `v-bind:`를 통해 상위 컴포넌트의 데이터 속성을 넘겨준다.

하위 컴포넌트에서 상위 컴포넌트로 자료를 전달하기 위해서는 이벤트를 이용한다. 이는 뷰의 단방향 데이터 흐름의 원칙 때문이다.

이벤트 발생은 `this.$emit('이벤트명');`으로 호출하고 수신하는 쪽에서는 `v-on:이벤트명="상위 컴포넌트의 메서드명"`으로 받아준다.

동일한 레벨의 컴포넌트가 자료를 주고 받기 위해서는 상위 컴포넌트로 이벤트를 발생시킨 후, 상위 컴포넌트가 props로 데이터를 내려 보내주어야 한다.

이러한 상황을 해결하는 방법이 이벤트 버스이다. 이벤트 버스는 옵저버 패턴과 유사하게 이벤트만 받는 컴포넌트를 만들고, 여기에 `eventBus.$emit('이벤트명', 데이터);`로 등록하고, 받는 컴포넌트는 `eventBus.$on('이벤트명', function(데이터) {});`로 받는다.

이벤트 버스를 이용하면, props 속성을 이용하지 않아도 되어서 편리하나, 컴포넌트가 많아지면, 흐름을 파악하기 어렵다. 이러한 문제를 해결하기 위해서 뷰엑스(Vuex)라는 상태 관리 도구가 이용된다.

## 라우터 & HTTP 통신

### 뷰 라우터

라우터는 웹페이지 간의 이동방식을 의미하는데, SPA(Single Page Application)에서 널리 이용되고 있다. 라우팅을 이용하면, 화면 전환시 깜박임이 발생할 수 있는데, 이를 매끄럽게 처리할 수 있다.

`router-link`는 `a` 태그로 전환되고, `router-view`는 라우터를 통해서 삽입되는 뷰 컴포넌트 위치가 지정된다. 뷰 라우터는 `var router = new VueRouter({ routers });`로 생성하고, `var app = new Vue({ router }).$mount('#app');`로 웹페이지에 붙여준다. 여기서 `$mount()`는 `el` 속성으로 컴포넌트를 붙여주는 기본 방식과 달리 라우터는 `el` 속성을 주지 않고, `$mount()`를 이용하여 강제로 인스턴스를 화면에 붙이는 방식으로 공식 문서에서 이러한 방식으로 안내하고 있다.

라우터를 이용할 때 해쉬태그가 생성되는데, 이를 제거하기 위해서는 `new VueRouter()`에서 `mode: 'history'` 속성을 추가하여 히스토리 모드로 설정해 준다.

네스티드 라우터는 컴포넌트 안에 `router-view`를 지정하고, `routes`에서 `children` 항목을 통해 하위 라우터를 지정할 수 있다. `user` 항목 아래 `posts` 항목을 두어, `user/posts`라는 항목으로 접근할 수 있다.

네스티드 라우터는 컴포넌트 수가 적을 때는 유용하게 이용할 수 있지만, 한번에 많은 수의 컴포넌트를 표시하기 어렵다. 이럴 때 네임드 뷰를 쓴다.

HTML 코드에서 `router-view`에 `name`속성으로 이름을 지정할 수 있다. 뷰 인스턴스에서 컴포넌트 설정 시 값으로 넣던 것 대신, 사전형으로 값을 입력해줄 수 있다. 이름이 없는 라우터 뷰는 `default` 키워드로 지정가능하다.

### 뷰 HTTP 통신

웹 앱 HTTP 통신의 대표적인 형태는 제이쿼리의 ajax가 있는데, 리액트나 앵귤러에서도 활발하게 사용된다. 뷰에서는 뷰 리소드와 액시오스(axios)라는 라이브러리를 많이 이용하고 있다.

뷰 리스스(resource)는 초기에는 공식 코어 라이브러리로 취급되었으나, 2016년 말 PageKit 팀의 라이브러리로 돌아갔다. 이는 코어팀에서 뷰 프레임워크에서 필수적인 요소라고 판단하지 않았기 때문인데, 여전히 많은 사람들이 쓰고 있다.

HTML 코드에 뷰 리소스 CDN를 추가하고, `this.$http.get('http://api.url.com/data.json').then(function(response) {});`와 같은 형식으로 처리된다. 받아온 자료는 문자열이기 때문에 `JSON.parse()`를 통해 JSON파일로 변환해주어야 한다.

액시오스는 뷰 커뮤니티에서 가장 많이 사용하는 HTTP 통신 라이브러리이다. 액시오스는 Promise 기반의 API를 지원한다.

사용방법은 역시 html 코드에 CDN 주소를 추가하고, `axios.get('URL 주소').then().catch();` 혹은 post로 사용할 수 있다. 혹은 옵션 속성을 넘겨주어, 처리할 수도 있다. 액시오스는 객체로 바로 받아주기 때문에, 따로 변환하지 않아도 된다.

## 템플릿 & 프로젝트 구성

템플릿은 마크업 속성과 뷰 인스턴스의 데이터와 로직을 연결하여, 사용자가 브라우저에서 볼 수 있는 HTML 코드를 변환해주는 속성으로, 템플릿을 이용하지 않고, HTML에 하드코딩한 후, `data` 속성으로 값을 지정하게 되면, 먼저 화면에 하드코딩한 형식이 보여지고, 값이 대치된다. 반면 템플릿을 이용하는 경우, 템플릿을 완성하기 전까지 아무것도 보이지 않다가 템플릿이 완성된 후 페이지에 붙게 된다.

데이터 바인딩은 `{{ }}` 문법과 `v-bind` 속성이 있다. `{{}}`는 뷰 인스턴스의 `data` 속성에서 지정한 사전형 자료에서 매칭되는 값으로 채워준다. HTML 코드에서 `<p v-bind:id="idA">`라고 작성하면, `<p>` 태그의 `id` 속성으로 값을 매칭시켜주는데, 그 레퍼런스가 되는 키워드가 `idA`가 된다. 즉 이 키는 뷰 인스턴스에서 `data` 속성으로 지정된 사전형에서 이용하는 키가 되며, 할당된 값과 연결하여, 갱신해준다.

`{{ }}`에서 data 속성을 적어주었지만, 간단한 자바스크립트 연산이 가능하다. 다만 식으로 해석하기 때문에, 분기 구분을 사용할 수는 없다. 복잡한 식은 사용가능하지만 가급적 지양하고, 뷰 인스턴스의 `computed` 속성으로 할당해준다. `computed` 속성을 이용하면, 캐싱효과를 볼 수 있다.

뷰 directive는 `v-` 접두사를 가진 모든 속성으로 자주 사용되는 디렉티브로 `v-if`, `v-show`, `v-for`, `v-bind`, `v-on`, `v-model`가 있다. `v-if`와 `v-show`의 차이는 후자는 해당 태그가 존재하되 화면에서만 보이지 않게 처리해준다. `v-on`은 화면 요소의 이벤트 등록을 위해서 사용되고, `v-model`은 폼(form)에서 주로 사용되는 속성으로 `<input>`, `<select>`, `<textarea>` 태그에서만 사용할 수 있다.

`v-on:click`으로 버튼 클릭 이벤트를 받을 수 있는데, 뷰 인스턴스 안에서 받을 때, 인자수를 맞춰서 파라미터를 받을 수 있다. html에서 호출할 때, 인자가 없으면, 받는 쪽에서 `function (event)`로 이벤트 객체를 받을 수 있다. 인자가 있을 때는 확인이 필요하다.

템플릿에서 `methods`와 `computed`의 차이는 캐싱과 자동 갱신 기능이라고 하겠다. `computed` 속성은 대상 데이터의 값이 변경되면, 자동으로 호출된다. `methods`는 명시적으로 호출이 될 때만 실행이 된다. 유사한 속성으로 `watch` 속성이 있다. 데이터를 관찰하다가 변화가 생기면 호출되는 속성인데, `computed` 속성은 내장 API를 이용하여 간단한 연산을 할 경우, `watch`는 데이터 호출과 같이 상대적으로 자원 소모가 큰 비동기 처리를 할 때 이용한다.
